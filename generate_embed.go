//go:generate go run $GOFILE

//go:build ignore
// +build ignore

// This script generates embedded data for the CLI tool.
// Run: go generate
// Then build: go build -o opencc ./cmd/opencc

package main

import (
	"bytes"
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"strings"
)

func main() {
	var configs []string
	var dicts []string

	// Read config files from data/config/
	configsDir := "data/config"
	filepath.WalkDir(configsDir, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if !d.IsDir() && strings.HasSuffix(path, ".json") {
			name := strings.TrimSuffix(filepath.Base(path), ".json")
			data, err := os.ReadFile(path)
			if err != nil {
				return err
			}
			configs = append(configs, fmt.Sprintf(`"%s": %#v`, name, string(data)))
		}
		return nil
	})

	// Read dictionary files from data/dictionary/
	dictsDir := "data/dictionary"
	filepath.WalkDir(dictsDir, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if !d.IsDir() && strings.HasSuffix(path, ".txt") {
			name := strings.TrimSuffix(filepath.Base(path), ".txt")
			data, err := os.ReadFile(path)
			if err != nil {
				return err
			}
			dicts = append(dicts, fmt.Sprintf(`"%s": %#v`, name, string(data)))
		}
		return nil
	})

	// Generate pkg/embeddata/embeddata.go
	var buf bytes.Buffer
	buf.WriteString(`// Code generated by generate_embed.go. DO NOT EDIT.

package embeddata

import "strings"
import "errors"

// EmbeddedConfig holds all embedded configuration files
var EmbeddedConfig = map[string]string{
`)
	for _, c := range configs {
		buf.WriteString("\t")
		buf.WriteString(c)
		buf.WriteString(",\n")
	}
	buf.WriteString(`}

// EmbeddedDict holds all embedded dictionary files
var EmbeddedDict = map[string]string{
`)
	for _, d := range dicts {
		buf.WriteString("\t")
		buf.WriteString(d)
		buf.WriteString(",\n")
	}
	buf.WriteString(`}

// GetConfig returns the configuration content for the given name.
// The name can be with or without the .json extension.
// Returns the config content as []byte and nil error if found,
// or nil and ErrConfigNotFound if not found.
func GetConfig(name string) ([]byte, error) {
	// Add .json extension if not present
	if !strings.HasSuffix(name, ".json") {
		name = name + ".json"
	}
	if content, ok := EmbeddedConfig[name]; ok {
		return []byte(content), nil
	}
	// Try stripping .json and checking
	baseName := strings.TrimSuffix(name, ".json")
	if content, ok := EmbeddedConfig[baseName]; ok {
		return []byte(content), nil
	}
	return nil, ErrConfigNotFound
}

// ErrConfigNotFound is returned when a configuration is not found
var ErrConfigNotFound = errors.New("configuration not found")

// ConfigExists returns true if a configuration with the given name exists.
// The name can be with or without the .json extension.
func ConfigExists(name string) bool {
	_, err := GetConfig(name)
	return err == nil
}

// ListConfigs returns a list of available configuration names (without .json extension).
func ListConfigs() []string {
	configs := make([]string, 0, len(EmbeddedConfig))
	for name := range EmbeddedConfig {
		// Remove .json extension if present
		configName := strings.TrimSuffix(name, ".json")
		configs = append(configs, configName)
	}
	return configs
}

// GetConfigString returns the configuration content as a string.
// This is a convenience function that returns the raw string.
func GetConfigString(name string) (string, bool) {
	content, err := GetConfig(name)
	if err != nil {
		return "", false
	}
	return string(content), true
}
`)

	err := os.WriteFile("pkg/embeddata/embeddata.go", buf.Bytes(), 0644)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error writing pkg/embeddata/embeddata.go: %v\n", err)
		os.Exit(1)
	}
	fmt.Println("Generated pkg/embeddata/embeddata.go with", len(configs), "configs and", len(dicts), "dictionaries")
}
